// ============================================================
// BLOOD STOCK SERVICE - PRODUCTION-OPTIMIZED SCHEMA
// ============================================================
// Version: 3.0.0 (Production-Ready)
// Date: 28 de fevereiro de 2026
// 
// OTIMIZAÇÕES IMPLEMENTADAS:
// ✅ Índices compostos estratégicos para FIFO e relatórios
// ✅ Índices parciais (WHERE conditions) para queries específicas
// ✅ Check constraints para validação de dados
// ✅ Triggers para consistência automática
// ✅ Particionamento preparado para tabelas grandes
// ✅ Soft deletes com deletedAt
// ✅ Campos de integração (externalId, metadata)
// ✅ Novas tabelas: BatchMovement, BloodBagReservation, AlertConfiguration, StockHistory
// ✅ Views materializadas otimizadas
// ✅ Auditoria completa com EventLog
//
// BREAKING CHANGES DA V2:
// + BatchMovement (movimentações em lote)
// + BloodBagReservation (reservas temporárias)
// + AlertConfiguration (alertas customizáveis)
// + StockHistory (snapshot diário de estoque)
// + Campos: externalId, metadata, deletedAt
// + Índices parciais e compostos avançados
// ============================================================

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pgcrypto, uuid_ossp]
}

// ============================================================
// ENUMS
// ============================================================

/// Tipos sanguíneos suportados (ABO + Rh)
enum BloodType {
  A_POS  @map("A+")
  A_NEG  @map("A-")
  B_POS  @map("B+")
  B_NEG  @map("B-")
  AB_POS @map("AB+")
  AB_NEG @map("AB-")
  O_POS  @map("O+")
  O_NEG  @map("O-")

  @@map("blood_type_enum")
}

/// Status de uma bolsa individual de sangue
enum BloodBagStatus {
  AVAILABLE   // Disponível para uso
  RESERVED    // Reservada (via BloodBagReservation)
  USED        // Utilizada em transfusão
  EXPIRED     // Vencida (expiresAt < NOW)
  DISCARDED   // Descartada por qualidade
  TRANSFERRED // Transferida para outro hemocentro
  QUARANTINE  // Em quarentena (análise pendente)

  @@map("blood_bag_status_enum")
}

/// Tipo de movimentação de estoque
enum MovementType {
  ENTRY_DONATION     // Entrada: Doação recebida
  ENTRY_TRANSFER_IN  // Entrada: Transferência recebida
  ENTRY_PURCHASE     // Entrada: Compra
  ENTRY_RETURN       // Entrada: Devolução
  EXIT_TRANSFUSION   // Saída: Transfusão
  EXIT_TRANSFER_OUT  // Saída: Transferência enviada
  EXIT_DISCARD       // Saída: Descarte de qualidade
  EXIT_EXPIRED       // Saída: Descarte vencimento
  EXIT_RESEARCH      // Saída: Pesquisa científica
  EXIT_SALE          // Saída: Venda
  ADJUSTMENT         // Ajuste de inventário

  @@map("movement_type_enum")
}

/// Papéis de usuário
enum UserRole {
  ADMIN       // Administrador geral
  MANAGER     // Gerente do hemocentro
  TECHNICIAN  // Técnico de laboratório
  DOCTOR      // Médico
  NURSE       // Enfermeiro
  AUDITOR     // Auditor (read-only)
  OPERATOR    // Operador (entrada/saída básica)

  @@map("user_role_enum")
}

/// Tipos de alertas
enum AlertType {
  LOW_STOCK       // Estoque baixo
  EXPIRING_SOON   // Vencendo em breve
  EXPIRED         // Vencido não descartado
  CRITICAL_STOCK  // Estoque crítico (0 unidades)
  HIGH_STOCK      // Estoque excedente (ocupação)
  BATCH_EXPIRING  // Lote inteiro vencendo

  @@map("alert_type_enum")
}

/// Severidade de alertas
enum AlertSeverity {
  INFO     // Informativo
  LOW      // Baixa
  MEDIUM   // Média
  HIGH     // Alta
  CRITICAL // Crítica

  @@map("alert_severity_enum")
}

/// Status de reserva
enum ReservationStatus {
  PENDING   // Pendente
  CONFIRMED // Confirmada
  EXPIRED   // Expirou (timeout)
  CANCELLED // Cancelada
  FULFILLED // Cumprida (bolsa usada)

  @@map("reservation_status_enum")
}

// ============================================================
// CORE ENTITIES
// ============================================================

/// Hemocentro/Empresa (Multi-tenant)
model Company {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String    @db.VarChar(255)
  cnpj        String    @unique @db.VarChar(18)
  address     String?   @db.Text
  phone       String?   @db.VarChar(20)
  email       String?   @db.VarChar(255)
  city        String?   @db.VarChar(100)
  state       String?   @db.VarChar(2)
  zipCode     String?   @db.VarChar(10) @map("zip_code")
  
  // Configurações
  timezone    String    @default("America/Sao_Paulo") @db.VarChar(50)
  locale      String    @default("pt-BR") @db.VarChar(10)
  
  // Integração
  externalId  String?   @unique @db.VarChar(100) @map("external_id")
  metadata    Json?     @db.JsonB // Dados extras (API keys, configs)
  
  // Controle
  isActive    Boolean   @default(true) @map("is_active")
  deletedAt   DateTime? @map("deleted_at") // Soft delete
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  batches            Batch[]
  users              User[]
  stockViews         StockView[]
  movements          Movement[]
  batchMovements     BatchMovement[]
  alerts             StockAlert[]
  alertConfigs       AlertConfiguration[]
  reservations       BloodBagReservation[]
  stockHistories     StockHistory[]

  @@index([cnpj])
  @@index([isActive, deletedAt]) // Soft delete queries
  @@index([city, state])
  @@index([externalId])
  @@map("company")
}

/// Usuário do sistema
model User {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId String    @db.Uuid @map("company_id")
  name      String    @db.VarChar(255)
  email     String    @unique @db.VarChar(255)
  password  String    @db.VarChar(255) // bcrypt hash
  role      UserRole
  cpf       String?   @unique @db.VarChar(14)
  phone     String?   @db.VarChar(20)
  
  // Segurança
  isActive     Boolean   @default(true) @map("is_active")
  lastLogin    DateTime? @map("last_login")
  loginAttempts Int      @default(0) @map("login_attempts")
  lockedUntil  DateTime? @map("locked_until")
  
  // Auditoria
  deletedAt    DateTime? @map("deleted_at")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  // Relations
  company            Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  movements          Movement[]
  batchMovements     BatchMovement[]
  reservations       BloodBagReservation[]
  eventLogs          EventLog[]

  @@index([companyId, isActive])
  @@index([email])
  @@index([role])
  @@index([deletedAt])
  @@map("user")
}

/// Lote de sangue recebido
model Batch {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId      String    @db.Uuid @map("company_id")
  code           String    @db.VarChar(100) // LOTE-2026-001234
  bloodType      BloodType @map("blood_type")
  
  // Datas
  receivedAt     DateTime  @map("received_at")
  expiresAt      DateTime  @map("expires_at")
  
  // Origem
  donorReference String?   @db.VarChar(255) @map("donor_reference")
  sourceLocation String?   @db.VarChar(255) @map("source_location")
  sourceHospital String?   @db.VarChar(255) @map("source_hospital")
  campaignId     String?   @db.VarChar(100) @map("campaign_id")
  
  // Qualidade
  testResults    Json?     @db.JsonB @map("test_results") // Resultados de exames
  certifiedBy    String?   @db.VarChar(255) @map("certified_by")
  certifiedAt    DateTime? @map("certified_at")
  
  // Integração
  externalId     String?   @db.VarChar(100) @map("external_id")
  metadata       Json?     @db.JsonB
  
  // Controle
  notes          String?   @db.Text
  deletedAt      DateTime? @map("deleted_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Relations
  company        Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  bloodBags      BloodBag[]
  batchMovements BatchMovement[]

  @@unique([companyId, code], name: "unique_batch_code_per_company")
  @@index([companyId, bloodType])
  @@index([expiresAt]) // Alertas de vencimento
  @@index([receivedAt])
  @@index([companyId, bloodType, expiresAt]) // FIFO por lote
  @@index([externalId])
  @@index([deletedAt])
  @@map("batch")
}

/// Bolsa individual de sangue (ENTIDADE PRINCIPAL)
model BloodBag {
  id             String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  batchId        String         @db.Uuid @map("batch_id")
  bagCode        String         @unique @db.VarChar(100) @map("bag_code") // BAG-LOTE-2026-001234-A
  bloodType      BloodType      @map("blood_type") // Denormalizado para performance
  volume         Int            @default(450) // mL
  status         BloodBagStatus @default(AVAILABLE)
  expiresAt      DateTime       @map("expires_at") // Denormalizado do Batch
  
  // Reserva (legacy - usar BloodBagReservation)
  reservedFor    String?        @db.Uuid @map("reserved_for")
  reservedAt     DateTime?      @map("reserved_at")
  reservedBy     String?        @db.Uuid @map("reserved_by")
  
  // Uso
  usedAt         DateTime?      @map("used_at")
  usedBy         String?        @db.Uuid @map("used_by")
  usedFor        String?        @db.Uuid @map("used_for") // Patient ID
  
  // Descarte
  discardedAt    DateTime?      @map("discarded_at")
  discardedBy    String?        @db.Uuid @map("discarded_by")
  discardReason  String?        @db.Text @map("discard_reason")
  
  // Qualidade
  qualityCheck   Json?          @db.JsonB @map("quality_check")
  
  // Integração
  externalId     String?        @db.VarChar(100) @map("external_id")
  metadata       Json?          @db.JsonB
  
  // Controle
  notes          String?        @db.Text
  deletedAt      DateTime?      @map("deleted_at")
  createdAt      DateTime       @default(now()) @map("created_at")
  updatedAt      DateTime       @updatedAt @map("updated_at")

  // Relations
  batch        Batch                 @relation(fields: [batchId], references: [id], onDelete: Cascade)
  movements    Movement[]
  reservations BloodBagReservation[]

  @@index([batchId])
  @@index([bloodType])
  @@index([status])
  @@index([expiresAt])
  
  // ÍNDICES COMPOSTOS OTIMIZADOS
  @@index([status, expiresAt]) // FIFO principal
  @@index([bloodType, status, expiresAt]) // FIFO por tipo
  @@index([batchId, status]) // Status por lote
  @@index([status, expiresAt, bloodType]) // FIFO + tipo
  
  // ÍNDICES PARCIAIS (PostgreSQL ONLY - adicionar via migration)
  // CREATE INDEX idx_available_bags_fifo ON blood_bag(expires_at, blood_type) 
  //   WHERE status = 'AVAILABLE' AND deleted_at IS NULL;
  // CREATE INDEX idx_expiring_soon ON blood_bag(expires_at, blood_type) 
  //   WHERE status = 'AVAILABLE' AND expires_at < NOW() + INTERVAL '7 days';
  
  @@index([externalId])
  @@index([deletedAt])
  @@map("blood_bag")
}

/// Movimentação individual de bolsa
model Movement {
  id          String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId   String       @db.Uuid @map("company_id")
  bloodBagId  String?      @db.Uuid @map("blood_bag_id") // Null para ajustes bulk
  userId      String       @db.Uuid @map("user_id")
  type        MovementType
  bloodType   BloodType    @map("blood_type") // Denormalizado
  quantity    Int          @default(1)
  
  // Rastreabilidade
  origin      String?      @db.VarChar(255) // Doador, campanha, hemocentro
  destination String?      @db.VarChar(255) // Paciente, hemocentro
  
  // Dados adicionais
  patientId   String?      @db.Uuid @map("patient_id")
  doctorId    String?      @db.Uuid @map("doctor_id")
  hospitalId  String?      @db.VarChar(100) @map("hospital_id")
  
  // Integração
  externalId  String?      @db.VarChar(100) @map("external_id")
  metadata    Json?        @db.JsonB
  
  // Controle
  notes       String?      @db.Text
  deletedAt   DateTime?    @map("deleted_at")
  createdAt   DateTime     @default(now()) @map("created_at")

  // Relations
  company  Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  bloodBag BloodBag? @relation(fields: [bloodBagId], references: [id], onDelete: SetNull)
  user     User      @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index([companyId, createdAt])
  @@index([bloodBagId])
  @@index([userId])
  @@index([type])
  @@index([bloodType])
  @@index([createdAt])
  
  // ÍNDICES COMPOSTOS PARA RELATÓRIOS
  @@index([companyId, bloodType, createdAt])
  @@index([companyId, type, createdAt])
  @@index([companyId, bloodType, type, createdAt])
  @@index([patientId])
  @@index([externalId])
  @@index([deletedAt])
  
  // PARTICIONAMENTO PREPARADO (adicionar via migration)
  // PARTITION BY RANGE (created_at)
  
  @@map("movement")
}

// ============================================================
// NOVAS TABELAS - FEATURES AVANÇADAS
// ============================================================

/// Movimentação em lote (múltiplas bolsas ao mesmo tempo)
model BatchMovement {
  id          String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId   String       @db.Uuid @map("company_id")
  batchId     String       @db.Uuid @map("batch_id")
  userId      String       @db.Uuid @map("user_id")
  type        MovementType
  bloodType   BloodType    @map("blood_type")
  
  // Quantidades
  totalBags   Int          @map("total_bags") // Quantidade de bolsas movimentadas
  totalVolume Int          @map("total_volume") // Volume total em mL
  
  // Rastreabilidade
  origin      String?      @db.VarChar(255)
  destination String?      @db.VarChar(255)
  
  // Referências
  bloodBagIds String[]     @map("blood_bag_ids") @db.Uuid[] // Array de IDs das bolsas
  
  // Integração
  externalId  String?      @db.VarChar(100) @map("external_id")
  metadata    Json?        @db.JsonB
  
  // Controle
  notes       String?      @db.Text
  deletedAt   DateTime?    @map("deleted_at")
  createdAt   DateTime     @default(now()) @map("created_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  batch   Batch   @relation(fields: [batchId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index([companyId, createdAt])
  @@index([batchId])
  @@index([userId])
  @@index([type])
  @@index([bloodType])
  @@index([companyId, bloodType, type, createdAt])
  @@index([externalId])
  @@index([deletedAt])
  @@map("batch_movement")
}

/// Reserva temporária de bolsa de sangue
model BloodBagReservation {
  id            String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId     String            @db.Uuid @map("company_id")
  bloodBagId    String            @db.Uuid @map("blood_bag_id")
  userId        String            @db.Uuid @map("user_id")
  status        ReservationStatus @default(PENDING)
  
  // Paciente/Procedimento
  patientId     String?           @db.Uuid @map("patient_id")
  patientName   String?           @db.VarChar(255) @map("patient_name")
  procedureType String?           @db.VarChar(100) @map("procedure_type") // "CIRURGIA", "EMERGENCIA"
  priority      Int               @default(3) // 1=CRITICAL, 2=HIGH, 3=MEDIUM, 4=LOW
  
  // Controle temporal
  reservedAt    DateTime          @default(now()) @map("reserved_at")
  expiresAt     DateTime          @map("expires_at") // Reserva expira após N horas
  confirmedAt   DateTime?         @map("confirmed_at")
  cancelledAt   DateTime?         @map("cancelled_at")
  fulfilledAt   DateTime?         @map("fulfilled_at")
  
  // Razão
  cancellationReason String?      @db.Text @map("cancellation_reason")
  
  // Integração
  externalId    String?           @db.VarChar(100) @map("external_id")
  metadata      Json?             @db.JsonB
  
  // Controle
  notes         String?           @db.Text
  deletedAt     DateTime?         @map("deleted_at")
  createdAt     DateTime          @default(now()) @map("created_at")
  updatedAt     DateTime          @updatedAt @map("updated_at")

  // Relations
  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  bloodBag BloodBag @relation(fields: [bloodBagId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index([companyId, status])
  @@index([bloodBagId])
  @@index([userId])
  @@index([patientId])
  @@index([expiresAt]) // Auto-expiração
  @@index([status, expiresAt]) // Limpar reservas expiradas
  @@index([priority, createdAt]) // Fila de prioridade
  @@index([externalId])
  @@index([deletedAt])
  @@map("blood_bag_reservation")
}

/// Configuração de alertas customizada por hemocentro
model AlertConfiguration {
  id               String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId        String    @db.Uuid @map("company_id")
  bloodType        BloodType @map("blood_type")
  alertType        AlertType @map("alert_type")
  
  // Thresholds
  threshold        Int? // Quantidade que dispara alerta
  daysBeforeExpiry Int?       @map("days_before_expiry") // Para EXPIRING_SOON
  
  // Severidade
  severity         AlertSeverity @default(MEDIUM)
  
  // Notificações
  emailEnabled     Boolean   @default(true) @map("email_enabled")
  emailRecipients  String[]  @map("email_recipients") @db.VarChar(255)[]
  smsEnabled       Boolean   @default(false) @map("sms_enabled")
  smsRecipients    String[]  @map("sms_recipients") @db.VarChar(20)[]
  
  // Controle
  isActive         Boolean   @default(true) @map("is_active")
  deletedAt        DateTime? @map("deleted_at")
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, bloodType, alertType], name: "unique_alert_config")
  @@index([companyId, isActive])
  @@index([alertType])
  @@index([deletedAt])
  @@map("alert_configuration")
}

/// Snapshot diário de estoque (para histórico e análises)
model StockHistory {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId       String    @db.Uuid @map("company_id")
  bloodType       BloodType @map("blood_type")
  snapshotDate    DateTime  @map("snapshot_date") @db.Date // Apenas data (sem hora)
  
  // Contadores (snapshot do dia)
  availableCount  Int       @default(0) @map("available_count")
  reservedCount   Int       @default(0) @map("reserved_count")
  usedCount       Int       @default(0) @map("used_count")
  expiredCount    Int       @default(0) @map("expired_count")
  discardedCount  Int       @default(0) @map("discarded_count")
  
  // Volumes
  availableVolume Int       @default(0) @map("available_volume")
  
  // Movimentações do dia
  entriesCount    Int       @default(0) @map("entries_count")
  exitsCount      Int       @default(0) @map("exits_count")
  
  // Controle
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, bloodType, snapshotDate], name: "unique_daily_snapshot")
  @@index([companyId, snapshotDate])
  @@index([snapshotDate]) // Análises temporais
  @@index([bloodType, snapshotDate])
  
  // PARTICIONAMENTO POR MÊS (adicionar via migration)
  // PARTITION BY RANGE (snapshot_date)
  
  @@map("stock_history")
}

// ============================================================
// VIEWS MATERIALIZADAS
// ============================================================

/// View materializada de estoque atual (atualizada via trigger)
model StockView {
  id                  String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId           String    @db.Uuid @map("company_id")
  bloodType           BloodType @map("blood_type")
  
  // Contadores
  availableCount      Int       @default(0) @map("available_count")
  reservedCount       Int       @default(0) @map("reserved_count")
  usedCount           Int       @default(0) @map("used_count")
  expiredCount        Int       @default(0) @map("expired_count")
  discardedCount      Int       @default(0) @map("discarded_count")
  quarantineCount     Int       @default(0) @map("quarantine_count")
  expiringSoonCount   Int       @default(0) @map("expiring_soon_count") // < 7 dias
  
  // Volumes
  totalVolume         Int       @default(0) @map("total_volume")
  availableVolume     Int       @default(0) @map("available_volume")
  
  // Metadados
  lastUpdated         DateTime  @default(now()) @map("last_updated")
  oldestExpirationDate DateTime? @map("oldest_expiration_date") // Bolsa mais antiga disponível
  newestExpirationDate DateTime? @map("newest_expiration_date") // Bolsa mais nova disponível
  
  // Estatísticas (últimos 30 dias)
  avgDailyUsage       Float?    @map("avg_daily_usage") @db.DoublePrecision
  avgDailyEntry       Float?    @map("avg_daily_entry") @db.DoublePrecision
  turnoverRate        Float?    @map("turnover_rate") @db.DoublePrecision // Taxa de rotatividade

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, bloodType], name: "unique_stock_per_company_blood_type")
  @@index([companyId])
  @@index([bloodType])
  @@index([availableCount]) // Alertas de estoque baixo
  @@index([expiringSoonCount]) // Alertas de vencimento
  @@map("stock_view")
}

/// Alertas de estoque
model StockAlert {
  id          String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  companyId   String        @db.Uuid @map("company_id")
  bloodType   BloodType     @map("blood_type")
  alertType   AlertType     @map("alert_type")
  severity    AlertSeverity
  message     String        @db.Text
  
  // Valores
  threshold   Int?          // Threshold configurado
  currentValue Int?         @map("current_value") // Valor atual que gerou alerta
  
  // Resolução
  isResolved  Boolean       @default(false) @map("is_resolved")
  resolvedAt  DateTime?     @map("resolved_at")
  resolvedBy  String?       @db.Uuid @map("resolved_by")
  resolutionNotes String?   @db.Text @map("resolution_notes")
  
  // Notificação
  notifiedAt  DateTime?     @map("notified_at")
  notifiedVia String[]      @map("notified_via") @db.VarChar(20)[] // ["EMAIL", "SMS"]
  
  // Controle
  deletedAt   DateTime?     @map("deleted_at")
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId, isResolved])
  @@index([bloodType])
  @@index([alertType])
  @@index([severity])
  @@index([createdAt])
  @@index([companyId, isResolved, severity]) // Dashboard de alertas
  @@index([deletedAt])
  @@map("stock_alert")
}

/// Auditoria completa via Event Sourcing
model EventLog {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  aggregateId   String   @db.Uuid @map("aggregate_id")
  aggregateType String   @db.VarChar(50) @map("aggregate_type") // "BloodBag", "Batch", etc.
  eventType     String   @db.VarChar(100) @map("event_type") // "BagCreated", "StatusChanged"
  eventData     Json     @map("event_data") @db.JsonB // Snapshot completo
  
  // Contexto
  userId        String?  @db.Uuid @map("user_id")
  ipAddress     String?  @db.VarChar(45) @map("ip_address")
  userAgent     String?  @db.Text @map("user_agent")
  
  // Controle
  timestamp     DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([aggregateId, timestamp])
  @@index([aggregateType])
  @@index([eventType])
  @@index([userId])
  @@index([timestamp])
  @@index([aggregateType, timestamp]) // Eventos por tipo
  
  // PARTICIONAMENTO POR MÊS (adicionar via migration)
  // PARTITION BY RANGE (timestamp)
  
  @@map("event_log")
}

// ============================================================
// VIEWS SQL (criar após migration)
// ============================================================

/*
-- View: Estoque em tempo real (alternativa ao StockView)
CREATE OR REPLACE VIEW v_stock_realtime AS
SELECT 
  b.company_id,
  bb.blood_type,
  COUNT(*) FILTER (WHERE bb.status = 'AVAILABLE' AND bb.expires_at > NOW()) AS available_count,
  COUNT(*) FILTER (WHERE bb.status = 'RESERVED') AS reserved_count,
  COUNT(*) FILTER (WHERE bb.status = 'USED') AS used_count,
  COUNT(*) FILTER (WHERE bb.status = 'EXPIRED') AS expired_count,
  COUNT(*) FILTER (WHERE bb.status = 'DISCARDED') AS discarded_count,
  COUNT(*) FILTER (WHERE bb.status = 'QUARANTINE') AS quarantine_count,
  COUNT(*) FILTER (WHERE bb.status = 'AVAILABLE' AND bb.expires_at BETWEEN NOW() AND NOW() + INTERVAL '7 days') AS expiring_soon_count,
  SUM(bb.volume) AS total_volume,
  SUM(bb.volume) FILTER (WHERE bb.status = 'AVAILABLE') AS available_volume,
  MIN(bb.expires_at) FILTER (WHERE bb.status = 'AVAILABLE' AND bb.expires_at > NOW()) AS oldest_expiration_date,
  MAX(bb.expires_at) FILTER (WHERE bb.status = 'AVAILABLE') AS newest_expiration_date
FROM blood_bag bb
JOIN batch b ON bb.batch_id = b.id
WHERE bb.deleted_at IS NULL AND b.deleted_at IS NULL
GROUP BY b.company_id, bb.blood_type;

-- View: Bolsas disponíveis com FIFO
CREATE OR REPLACE VIEW v_available_bags_fifo AS
SELECT 
  bb.*,
  b.company_id,
  RANK() OVER (PARTITION BY b.company_id, bb.blood_type ORDER BY bb.expires_at ASC) AS fifo_rank
FROM blood_bag bb
JOIN batch b ON bb.batch_id = b.id
WHERE bb.status = 'AVAILABLE' 
  AND bb.expires_at > NOW()
  AND bb.deleted_at IS NULL
  AND b.deleted_at IS NULL;

-- View: Reservas ativas
CREATE OR REPLACE VIEW v_active_reservations AS
SELECT 
  r.*,
  bb.bag_code,
  bb.blood_type,
  bb.volume,
  u.name AS user_name,
  c.name AS company_name
FROM blood_bag_reservation r
JOIN blood_bag bb ON r.blood_bag_id = bb.id
JOIN "user" u ON r.user_id = u.id
JOIN company c ON r.company_id = c.id
WHERE r.status IN ('PENDING', 'CONFIRMED')
  AND r.expires_at > NOW()
  AND r.deleted_at IS NULL;

-- View: Análise de movimentações (últimos 30 dias)
CREATE OR REPLACE VIEW v_movement_analysis_30d AS
SELECT 
  m.company_id,
  m.blood_type,
  m.type,
  COUNT(*) AS total_movements,
  SUM(m.quantity) AS total_quantity,
  DATE_TRUNC('day', m.created_at) AS movement_date
FROM movement m
WHERE m.created_at >= NOW() - INTERVAL '30 days'
  AND m.deleted_at IS NULL
GROUP BY m.company_id, m.blood_type, m.type, DATE_TRUNC('day', m.created_at);
*/

// ============================================================
// TRIGGERS (criar após migration)
// ============================================================

/*
-- Trigger 1: Atualizar StockView automaticamente
CREATE OR REPLACE FUNCTION fn_update_stock_view()
RETURNS TRIGGER AS $$
DECLARE
  v_company_id UUID;
  v_blood_type TEXT;
BEGIN
  -- Pegar company_id do batch
  SELECT b.company_id, NEW.blood_type INTO v_company_id, v_blood_type
  FROM batch b WHERE b.id = NEW.batch_id;
  
  -- Atualizar contadores na StockView
  UPDATE stock_view
  SET
    available_count = (
      SELECT COUNT(*) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'AVAILABLE' 
        AND bb.expires_at > NOW()
        AND bb.deleted_at IS NULL
    ),
    reserved_count = (
      SELECT COUNT(*) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'RESERVED'
        AND bb.deleted_at IS NULL
    ),
    used_count = (
      SELECT COUNT(*) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'USED'
        AND bb.deleted_at IS NULL
    ),
    expired_count = (
      SELECT COUNT(*) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'EXPIRED'
        AND bb.deleted_at IS NULL
    ),
    discarded_count = (
      SELECT COUNT(*) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'DISCARDED'
        AND bb.deleted_at IS NULL
    ),
    quarantine_count = (
      SELECT COUNT(*) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'QUARANTINE'
        AND bb.deleted_at IS NULL
    ),
    expiring_soon_count = (
      SELECT COUNT(*) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'AVAILABLE'
        AND bb.expires_at BETWEEN NOW() AND NOW() + INTERVAL '7 days'
        AND bb.deleted_at IS NULL
    ),
    available_volume = (
      SELECT COALESCE(SUM(bb.volume), 0) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'AVAILABLE'
        AND bb.deleted_at IS NULL
    ),
    oldest_expiration_date = (
      SELECT MIN(bb.expires_at) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'AVAILABLE'
        AND bb.expires_at > NOW()
        AND bb.deleted_at IS NULL
    ),
    newest_expiration_date = (
      SELECT MAX(bb.expires_at) FROM blood_bag bb JOIN batch b ON bb.batch_id = b.id
      WHERE b.company_id = v_company_id 
        AND bb.blood_type = v_blood_type::blood_type_enum
        AND bb.status = 'AVAILABLE'
        AND bb.deleted_at IS NULL
    ),
    last_updated = NOW()
  WHERE company_id = v_company_id AND blood_type = v_blood_type::blood_type_enum;
  
  -- Criar registro se não existir
  IF NOT FOUND THEN
    INSERT INTO stock_view (company_id, blood_type, available_count, reserved_count, used_count, expired_count, discarded_count)
    VALUES (v_company_id, v_blood_type::blood_type_enum, 0, 0, 0, 0, 0);
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_blood_bag_update_stock_view
AFTER INSERT OR UPDATE OF status ON blood_bag
FOR EACH ROW
EXECUTE FUNCTION fn_update_stock_view();

-- Trigger 2: Marcar bolsas como EXPIRED automaticamente
CREATE OR REPLACE FUNCTION fn_mark_expired_bags()
RETURNS INTEGER AS $$
DECLARE
  v_updated_count INTEGER;
BEGIN
  WITH updated AS (
    UPDATE blood_bag
    SET status = 'EXPIRED'::blood_bag_status_enum
    WHERE status = 'AVAILABLE'::blood_bag_status_enum
      AND expires_at < NOW()
      AND deleted_at IS NULL
    RETURNING id
  )
  SELECT COUNT(*) INTO v_updated_count FROM updated;
  
  RETURN v_updated_count;
END;
$$ LANGUAGE plpgsql;

-- Job agendado (rodar a cada hora via pg_cron ou externa)
-- SELECT fn_mark_expired_bags();

-- Trigger 3: Validar consistência entre BloodBag e Batch
CREATE OR REPLACE FUNCTION fn_validate_blood_bag_batch_consistency()
RETURNS TRIGGER AS $$
DECLARE
  v_batch_blood_type TEXT;
  v_batch_expires_at TIMESTAMP;
BEGIN
  -- Buscar bloodType e expiresAt do Batch
  SELECT blood_type, expires_at INTO v_batch_blood_type, v_batch_expires_at
  FROM batch WHERE id = NEW.batch_id;
  
  -- Validar bloodType
  IF NEW.blood_type::TEXT != v_batch_blood_type THEN
    RAISE EXCEPTION 'BloodBag.bloodType (%) must match Batch.bloodType (%)', NEW.blood_type, v_batch_blood_type;
  END IF;
  
  -- Validar expiresAt (BloodBag não pode expirar após Batch)
  IF NEW.expires_at > v_batch_expires_at THEN
    RAISE EXCEPTION 'BloodBag.expiresAt cannot be later than Batch.expiresAt';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_blood_bag_consistency
BEFORE INSERT OR UPDATE ON blood_bag
FOR EACH ROW
EXECUTE FUNCTION fn_validate_blood_bag_batch_consistency();

-- Trigger 4: Expirar reservas automaticamente
CREATE OR REPLACE FUNCTION fn_expire_reservations()
RETURNS INTEGER AS $$
DECLARE
  v_expired_count INTEGER;
BEGIN
  WITH expired AS (
    UPDATE blood_bag_reservation
    SET status = 'EXPIRED'::reservation_status_enum
    WHERE status IN ('PENDING'::reservation_status_enum, 'CONFIRMED'::reservation_status_enum)
      AND expires_at < NOW()
      AND deleted_at IS NULL
    RETURNING id
  )
  SELECT COUNT(*) INTO v_expired_count FROM expired;
  
  -- Liberar bolsas reservadas
  UPDATE blood_bag
  SET status = 'AVAILABLE'::blood_bag_status_enum,
      reserved_for = NULL,
      reserved_at = NULL,
      reserved_by = NULL
  WHERE id IN (
    SELECT blood_bag_id FROM blood_bag_reservation
    WHERE status = 'EXPIRED'::reservation_status_enum 
      AND deleted_at IS NULL
  );
  
  RETURN v_expired_count;
END;
$$ LANGUAGE plpgsql;

-- Job agendado (rodar a cada 15 minutos)
-- SELECT fn_expire_reservations();

-- Trigger 5: Criar snapshot diário de estoque
CREATE OR REPLACE FUNCTION fn_create_daily_stock_snapshot()
RETURNS INTEGER AS $$
DECLARE
  v_snapshot_count INTEGER;
BEGIN
  INSERT INTO stock_history (
    company_id, 
    blood_type, 
    snapshot_date,
    available_count,
    reserved_count,
    used_count,
    expired_count,
    discarded_count,
    available_volume,
    entries_count,
    exits_count
  )
  SELECT 
    sv.company_id,
    sv.blood_type,
    CURRENT_DATE,
    sv.available_count,
    sv.reserved_count,
    sv.used_count,
    sv.expired_count,
    sv.discarded_count,
    sv.available_volume,
    (SELECT COUNT(*) FROM movement m 
     WHERE m.company_id = sv.company_id 
       AND m.blood_type = sv.blood_type 
       AND m.type IN ('ENTRY_DONATION', 'ENTRY_TRANSFER_IN', 'ENTRY_PURCHASE', 'ENTRY_RETURN')
       AND DATE(m.created_at) = CURRENT_DATE
       AND m.deleted_at IS NULL),
    (SELECT COUNT(*) FROM movement m 
     WHERE m.company_id = sv.company_id 
       AND m.blood_type = sv.blood_type 
       AND m.type IN ('EXIT_TRANSFUSION', 'EXIT_TRANSFER_OUT', 'EXIT_DISCARD', 'EXIT_EXPIRED', 'EXIT_RESEARCH', 'EXIT_SALE')
       AND DATE(m.created_at) = CURRENT_DATE
       AND m.deleted_at IS NULL)
  FROM stock_view sv
  ON CONFLICT (company_id, blood_type, snapshot_date) DO UPDATE
  SET 
    available_count = EXCLUDED.available_count,
    reserved_count = EXCLUDED.reserved_count,
    used_count = EXCLUDED.used_count,
    expired_count = EXCLUDED.expired_count,
    discarded_count = EXCLUDED.discarded_count,
    available_volume = EXCLUDED.available_volume,
    entries_count = EXCLUDED.entries_count,
    exits_count = EXCLUDED.exits_count;
  
  GET DIAGNOSTICS v_snapshot_count = ROW_COUNT;
  RETURN v_snapshot_count;
END;
$$ LANGUAGE plpgsql;

-- Job agendado (rodar diariamente à meia-noite)
-- SELECT fn_create_daily_stock_snapshot();

-- Trigger 6: Verificar alertas automaticamente
CREATE OR REPLACE FUNCTION fn_check_stock_alerts()
RETURNS INTEGER AS $$
DECLARE
  v_alert_count INTEGER := 0;
  v_config RECORD;
  v_current_value INTEGER;
  v_severity TEXT;
BEGIN
  -- Para cada configuração de alerta ativa
  FOR v_config IN 
    SELECT * FROM alert_configuration 
    WHERE is_active = TRUE AND deleted_at IS NULL
  LOOP
    -- Buscar valor atual do StockView
    SELECT available_count INTO v_current_value
    FROM stock_view
    WHERE company_id = v_config.company_id 
      AND blood_type = v_config.blood_type;
    
    -- Verificar se deve criar alerta (LOW_STOCK, CRITICAL_STOCK)
    IF v_config.alert_type IN ('LOW_STOCK', 'CRITICAL_STOCK') THEN
      IF v_current_value <= v_config.threshold THEN
        -- Criar alerta se não existir ativo
        INSERT INTO stock_alert (
          company_id, blood_type, alert_type, severity, message, threshold, current_value
        )
        SELECT 
          v_config.company_id,
          v_config.blood_type,
          v_config.alert_type,
          v_config.severity,
          FORMAT('Estoque %s para %s: %s unidades (mínimo: %s)', 
                 v_config.alert_type, v_config.blood_type, v_current_value, v_config.threshold),
          v_config.threshold,
          v_current_value
        WHERE NOT EXISTS (
          SELECT 1 FROM stock_alert 
          WHERE company_id = v_config.company_id 
            AND blood_type = v_config.blood_type 
            AND alert_type = v_config.alert_type
            AND is_resolved = FALSE
            AND deleted_at IS NULL
        );
        
        v_alert_count := v_alert_count + 1;
      END IF;
    END IF;
  END LOOP;
  
  RETURN v_alert_count;
END;
$$ LANGUAGE plpgsql;

-- Job agendado (rodar a cada 1 hora)
-- SELECT fn_check_stock_alerts();
*/

// ============================================================
// ÍNDICES PARCIAIS (adicionar via migration raw SQL)
// ============================================================

/*
-- ÍNDICES PARCIAIS para melhor performance em queries específicas

-- Bolsas disponíveis (FIFO)
CREATE INDEX IF NOT EXISTS idx_blood_bag_available_fifo 
ON blood_bag(expires_at, blood_type) 
WHERE status = 'AVAILABLE' AND deleted_at IS NULL;

-- Bolsas vencendo em breve
CREATE INDEX IF NOT EXISTS idx_blood_bag_expiring_soon 
ON blood_bag(expires_at, blood_type, batch_id) 
WHERE status = 'AVAILABLE' 
  AND expires_at < NOW() + INTERVAL '7 days'
  AND deleted_at IS NULL;

-- Bolsas vencidas não descartadas
CREATE INDEX IF NOT EXISTS idx_blood_bag_expired_not_discarded 
ON blood_bag(expires_at, blood_type) 
WHERE expires_at < NOW() 
  AND status NOT IN ('DISCARDED', 'EXPIRED')
  AND deleted_at IS NULL;

-- Reservas ativas
CREATE INDEX IF NOT EXISTS idx_reservation_active 
ON blood_bag_reservation(expires_at, priority, created_at) 
WHERE status IN ('PENDING', 'CONFIRMED') 
  AND deleted_at IS NULL;

-- Movimentos recentes (últimos 30 dias)
CREATE INDEX IF NOT EXISTS idx_movement_recent 
ON movement(company_id, blood_type, type, created_at) 
WHERE created_at >= NOW() - INTERVAL '30 days'
  AND deleted_at IS NULL;

-- Alertas não resolvidos
CREATE INDEX IF NOT EXISTS idx_alert_unresolved 
ON stock_alert(company_id, severity, created_at) 
WHERE is_resolved = FALSE 
  AND deleted_at IS NULL;
*/

// ============================================================
// CHECK CONSTRAINTS (adicionar via migration raw SQL)
// ============================================================

/*
-- Validações de dados

-- BloodBag: volume deve ser positivo
ALTER TABLE blood_bag 
ADD CONSTRAINT chk_blood_bag_volume_positive 
CHECK (volume > 0);

-- BloodBag: expiresAt deve ser futuro ao criar
ALTER TABLE blood_bag 
ADD CONSTRAINT chk_blood_bag_expires_at_future 
CHECK (expires_at > created_at);

-- Movement: quantity deve ser positivo
ALTER TABLE movement 
ADD CONSTRAINT chk_movement_quantity_positive 
CHECK (quantity > 0);

-- BatchMovement: totalBags e totalVolume positivos
ALTER TABLE batch_movement 
ADD CONSTRAINT chk_batch_movement_totals_positive 
CHECK (total_bags > 0 AND total_volume > 0);

-- BloodBagReservation: expiresAt > reservedAt
ALTER TABLE blood_bag_reservation 
ADD CONSTRAINT chk_reservation_expires_after_reserved 
CHECK (expires_at > reserved_at);

-- AlertConfiguration: threshold positivo se presente
ALTER TABLE alert_configuration 
ADD CONSTRAINT chk_alert_config_threshold_positive 
CHECK (threshold IS NULL OR threshold >= 0);

-- StockHistory: contadores não negativos
ALTER TABLE stock_history 
ADD CONSTRAINT chk_stock_history_counts_non_negative 
CHECK (
  available_count >= 0 AND 
  reserved_count >= 0 AND 
  used_count >= 0 AND 
  expired_count >= 0 AND 
  discarded_count >= 0 AND
  available_volume >= 0
);
*/

// ============================================================
// EXTENSIONS (criar antes das migrations)
// ============================================================

/*
-- PostgreSQL Extensions necessárias

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";      -- UUIDs
CREATE EXTENSION IF NOT EXISTS "pgcrypto";       -- Criptografia
CREATE EXTENSION IF NOT EXISTS "pg_trgm";        -- Full-text search
CREATE EXTENSION IF NOT EXISTS "btree_gin";      -- Índices GIN para arrays
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"; -- Análise de queries
-- CREATE EXTENSION IF NOT EXISTS "pg_cron";     -- Jobs agendados (se disponível)
*/

// ============================================================
// NOTAS DE IMPLEMENTAÇÃO
// ============================================================

/*
MIGRATION CHECKLIST:

1. Criar extensions (uuid-ossp, pgcrypto, pg_trgm, btree_gin)
2. Rodar `npx prisma migrate dev` para criar tabelas
3. Adicionar índices parciais (SQL raw acima)
4. Adicionar check constraints (SQL raw acima)
5. Criar views SQL (v_stock_realtime, v_available_bags_fifo, etc.)
6. Criar triggers (fn_update_stock_view, fn_mark_expired_bags, etc.)
7. Popular AlertConfiguration padrão para cada hemocentro
8. Criar jobs agendados:
   - A cada hora: fn_mark_expired_bags()
   - A cada 15min: fn_expire_reservations()
   - A cada hora: fn_check_stock_alerts()
   - Diário (meia-noite): fn_create_daily_stock_snapshot()
9. Configurar particionamento para Movement, EventLog, StockHistory

PARTICIONAMENTO (PostgreSQL 10+):

-- Movement (por mês)
CREATE TABLE movement_partitioned (LIKE movement INCLUDING ALL);
ALTER TABLE movement_partitioned 
  ADD PRIMARY KEY (id, created_at);
-- Criar partições manualmente ou via pg_partman

-- EventLog (por mês)
CREATE TABLE event_log_partitioned (LIKE event_log INCLUDING ALL);
ALTER TABLE event_log_partitioned 
  ADD PRIMARY KEY (id, timestamp);

-- StockHistory (por mês)
CREATE TABLE stock_history_partitioned (LIKE stock_history INCLUDING ALL);
ALTER TABLE stock_history_partitioned 
  ADD PRIMARY KEY (id, snapshot_date);

PERFORMANCE TIPS:

1. VACUUM ANALYZE diário nas tabelas principais
2. Monitorar pg_stat_statements para queries lentas
3. Aumentar shared_buffers para 25% da RAM
4. Configurar work_mem adequadamente (256MB+)
5. Ativar auto_vacuum agressivo
6. Considerar read replicas para relatórios
7. Usar connection pooling (PgBouncer)
8. Cache Redis para StockView (TTL 5min)

BACKUP:

1. pg_dump diário completo
2. Point-in-time recovery (WAL archiving)
3. Backup incremental via pg_basebackup
4. Replicação streaming para DR

MONITORAMENTO:

1. Prometheus + Grafana para métricas
2. Lokki ou ELK para logs
3. Alertas para:
   - Conexões > 80%
   - Disk usage > 80%
   - Query time > 5s
   - Replication lag > 10s
*/
